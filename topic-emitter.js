// Generated by CoffeeScript 1.8.0

/*

nodejs style event emitter combined with rabbitmq style exchange
event can have heirarachy via '.' separator
'*" match a token (between .)
 */

(function() {
  var TopicEmitter, assert,
    __slice = [].slice;

  module.exports = TopicEmitter = (function() {
    function TopicEmitter() {
      this.evTree = {};
    }

    TopicEmitter.prototype.on = function(name, cb) {
      var last, path, t, tree, _i, _j, _len, _ref;
      _ref = name.split("."), path = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), last = _ref[_i++];
      tree = this.evTree;
      for (_j = 0, _len = path.length; _j < _len; _j++) {
        t = path[_j];
        tree = tree[t] || (tree[t] = {
          __ehs: []
        });
      }
      tree[last] || (tree[last] = {
        __ehs: []
      });
      return tree[last].__ehs.push(cb);
    };

    TopicEmitter.prototype.off = function(name, cb) {
      var i, last, path, t, tree, _i, _j, _len, _ref;
      _ref = name.split("."), path = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), last = _ref[_i++];
      tree = this.evTree;
      for (_j = 0, _len = path.length; _j < _len; _j++) {
        t = path[_j];
        if (tree != null) {
          tree = tree[t];
        }
      }
      if (tree != null) {
        if (cb == null) {
          return delete tree[last];
        } else {
          i = tree[last].__ehs.indexOf(cb);
          if (i !== -1) {
            return tree[last].__ehs.splice(i, 1);
          }
        }
      }
    };

    TopicEmitter.prototype.destory = function() {
      return this.evTree = {};
    };

    TopicEmitter.prototype.h = function(event) {
      return this.emit.bind(this, event);
    };

    TopicEmitter.prototype.emit = function(event, param) {
      var name, walk;
      name = 'string' === typeof event ? event : event.name;
      walk = (function(_this) {
        return function(toks, tree, match) {
          var h, t, _i, _j, _len, _len1, _ref, _ref1, _results;
          if (tree == null) {
            return;
          }
          t = toks[0];
          if (toks.length === 1) {
            if (t in tree) {
              _ref = tree[t].__ehs;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                h = _ref[_i];
                h(event, param, match.slice(0, -1));
              }
            }
            if ('*' in tree) {
              _ref1 = tree['*'].__ehs;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                h = _ref1[_j];
                _results.push(h(event, param, match + t));
              }
              return _results;
            }
          } else {
            if (t in tree) {
              walk(toks.slice(1), tree[t], match);
            }
            if ('*' in tree) {
              return walk(toks.slice(1), tree['*'], match + t + ".");
            }
          }
        };
      })(this);
      return walk(name.split("."), this.evTree, '');
    };

    return TopicEmitter;

  })();

  if (require.main === module) {
    assert = require("assert");
    (function() {
      var emitter;
      emitter = new TopicEmitter();
      emitter.on('m1.button.*', function(event, param, match) {
        return assert(false);
      });
      emitter.on('m1.button.send.click', function(event, param, match) {
        return assert(true);
      });
      emitter.on('*.button.*.click', function(event, param, match) {
        return assert(match === "m1.send");
      });
      return emitter.emit('m1.button.send.click');
    })();
  }

}).call(this);

//# sourceMappingURL=topic-emitter.js.map
